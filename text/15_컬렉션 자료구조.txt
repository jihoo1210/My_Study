1. 컬렉션 프레임 워크
- 객체들을 효율적으로 추가, 삭제, 검색할 수 있도록 관련된 인터페이스와 클래스들을 java.util 페키지에 포함시켜 놓았다.
-- 컬렉션 프레임 워크라고 부른다.

- Collection
-- List
-- Set
- Map

2. List 컬렉션
- 객체를 인덱스로 관리한다.
기능     | 메소드                      | 설명
객체 추가 | boolean add(E e)           | 주어진 객체를 맨 끝에 추가
객체 추가 | void add(int index, E e)   | 주어진 인덱스에 객체를 추가
객체 추가 | set(int index, E e)        | 주어진 인덱스의 객체를 변경

객체 검색 | boolean contains(Object o) | 주어진 객체가 저장되어 있는지 여부
객체 검색 | E get(int index)           | 주어진 인덱스에 저장된 객체를 리턴
객체 검색 | isEmpty()                  | 컬렉션이 비어 있는지 조사
객체 검색 | int size()                 | 저장되어 있는 객체 수를 리턴

객체 삭제 | void clear()               | 저장된 모든 객체를 삭제
객체 삭제 | E remove(int index)        | 주어진 객체에 저장된 객체를 삭제
객체 삭제 | boolean remove(Object o)   | 주어진 객체를 삭제

2-1. ArrayList
- 객체를 추가하면 내부 배열에 객체가 저장된다.
- 제한 없이 객체를 추가할 수 있다.
- 객체의 번지를 저장한다.
-- 중복된 객체는 동일한 번지를 저장한다.

2-2. Vector
- 멀티 스레드가 동시에 Vector() 메소드를 실행할 수 없다.

2-3. LinkedList
- 인접 객체를 체인처럼 연결해서 관리한다.
- 빈번한 삭제화 삽입이 일어나는 곳에서 좋은 성능을 발휘한다.

3. Set 컬렉션
- 저장 순서가 유지되지 않는다.
- 객체를 중복 저장할 수 없다.
기능     | 메소드                      | 설명
객체 추가 | boolean add(E e)           | 주어진 객체를 저장

객체 검색 | boolean contains(Object o) | 주어진 객체가 저장되어 있는지 여부
객체 검색 | isEmpty()                  | 컬렉션이 비어 있는지 조사
객체 검색 | Iterator<E> iterator()     | 저장된 객체를 한 번씩 가져오는 반복자 리턴
객체 검색 | int size()                 | 저장되어 있는 객체 수를 리턴

객체 삭제 | void clear()               | 저장된 모든 객체를 삭제
객체 삭제 | boolean remove(Object o)   | 주어진 객체를 삭제

3-1. HashSet
- 동일한 객체: hashCode()와 equals()가 전부 참인 경우를 말한다.
-- hashCode: 메모리 주소를 통해 생성한 코드

- iterator
-- 반복자를 얻어 객체를 하나씩 반환한다.
-- Iterator<E> iterator = set.iterator();
--- 지원하는 메소드
- hasNext(): 다음 객체가 있다면 true를 리턴한다.
- next(): 컬렉션에서 객체 하나를 가져온다.
- remove(): next()로 가져온 객체를 Set 컬렉션에서 제거한다.

4. Map 컬렉션
- 키와 값으로 구성된 엔트리 객체를 저장한다.
- 키는 중복 저장할 수 없지만 값은 중복 저장할 수 있다.
기능     | 메소드                               | 설명
객체 추가 | V put(K key, V value)               | 주어진 키와 값을 추가, 저장이 되면 값을 리턴

객체 검색 | boolean containsKey(Object key)     | 주어진 키가 저장되어 있는지 여부
객체 검색 | boolean containsValue(Object value) | 주어진 값이 저장되어 있는지 여부
객체 검색 | Set<Map.Entry<k, V>> entrySet()     | 모든 Map.Entry를 Set 객체에 담아서 리턴
객체 검색 | V get(Object key)                   | 주어진 키의 값을 리턴
객체 검색 | isEmpty()                           | 컬렉션이 비어 있는지 조사
객체 검색 | Set<K> keySet()                     | 모든 키를 Set 객체에 담아서 리턴
객체 검색 | int size()                          | 저장되어 있는 키의 수를 리턴
객체 검색 | Collection<V> values()              | 저장되어 있는 모든 값 Collection에 담아서 리턴

객체 삭제 | void clear()                        | 저장된 모든 Map.Entry(키와 값)를 삭제
객체 삭제 | V remove(Object key)                | 주어진 키와 일치하는 Map.Entry 삭제, 삭제되면 값을 리턴

4-1. HashMap
- 동일 키: hashCode()와 equals() 메소드가 true를 리턴할 경우.

4-2. HashTable
- 동기화된 메소드로 구성되어 있는 HashMap이다.

4-3. Properties
- 키와 값을 String으로 제한한 HashMap이다.
- 주로 프로퍼티 파일을 읽을 때 사용한다.
-- 프로파티 파일: 키와 값이 '=' 기호로 연결되어 있는 텍스트 파일이다.

5. 검색 기능을 강화시킨 컬렉션

5-1. TreeSet
- 이진 트리를 기반으로 한 Set 컬렉션
-- 부모 노드의 객체와 비교해서 낮은 것은 왼쪽 노드에, 높은 것은 오른쪽 노드에 저장한다.

리턴 타입        | 메소드                | 설명
E               | first()              | 제일 낮은 객체를 리턴
E               | last()               | 제일 높은 객체를 리턴
E               | lower(E e)           | 주어진 객체 바로 아래 객체를 리턴
E               | higher(E e)          | 주어진 객체 바로 위 객체를 리턴
E               | floor(E e)           | 주어진 객체와 동등한 객체가 있다면 해당 객체를, 없다면 바로 아래 객체를 리턴
E               | ceiling(E e)         | 주어진 객체와 동등한 객체가 있다면 해당 객체를, 없다면 바로 위 객체를 리턴
E               | pollFirst()          | 제일 낮은 객체를 리턴하고 컬렉션에서 제거함
E               | pollLast()           | 제일 높은 객체를 리턴하고 컬렉션에서 제거함
Iterator<E>     | descendingIterator() | 내림차순으로 정렬된 Iterator를 리턴
NavigableSet<E> | descendingSet()      | 내림차순으로 정렬된 NavigableSet을 리턴
NavigableSet<E> | headSet(E toElement, boolean inclusive) | 주어진 객체보다 낮은 객체들을 NavigableSet으로 리턴
NavigableSet<E> | tailSet(E toElement, boolean inclusive) | 주어진 객체보다 높은 객체들을 NavigableSet으로 리턴
NavigableSet<E> | subSet(E fromElement, boolean fromInclusive, E toElement, boolean toInclusive) | 주어진 객체 사이의 객체들을 NavigableSet으로 리턴
- NavigableSet: 해당 메서드들을 사용할 수 있는 Set

5-2. TreeMap
- 이진 트리를 기반으로 한 Map 컬렉션
- 키와 값이 저장된 Entry를 저장한다.
- 키 값을 비교해서 정렬한다.

리턴 타입        | 메소드                | 설명
Map.Entry<K, V> | firstEntry()         | 제일 낮은 Map.Entry를 리턴
Map.Entry<K, V> | lastEntry()          | 제일 높은 Map.Entry를 리턴
Map.Entry<K, V> | lowerEntry(K key)    | 주어진 키 바로 아래 Map.Entry를 리턴
Map.Entry<K, V> | higherEntry(K key)   | 주어진 키 바로 위 Map.Entry를 리턴
Map.Entry<K, V> | floorEntry(K key)    | 주어진 키와 동등한 키가 있다면 해당 Map.Entry를, 없다면 바로 아래 Map.Entry를 리턴
Map.Entry<K, V> | ceilingEntry(K key)  | 주어진 키와 동등한 키가 있다면 해당 Map.Entry를, 없다면 바로 위 Map.Entry를 리턴
Map.Entry<K, V> | pollFirstEntry()     | 제일 낮은 Map.Entry를 리턴하고 컬렉션에서 제거함
Map.Entry<K, V> | pollLastEntry()      | 제일 높은 Map.Entry를 리턴하고 컬렉션에서 제거함
NavigableSet<E> | descendingKeySet()   | 내림차순으로 정렬된 NavigableSet을 리턴
NavigableMap<E> | descendingMap()      | 내림차순으로 정렬된 Map.Entry의 NavigableMap을 리턴
NavigableMap<E> | headMap(K toKey, boolean inclusive) | 주어진 객체보다 낮은 Map.Entry들을 NavigableSet으로 리턴
NavigableMap<E> | tailSet(K fromKey, boolean inclusive) | 주어진 객체보다 높은 Map.Entry들을 NavigableSet으로 리턴
NavigableMap<E> | subSet(K toKey, boolean fromInclusive, K fromKey, boolean toInclusive) | 주어진 객체 사이의 Map.Entry들을 NavigableSet으로 리턴
- NavigableMap: 해당 메서드들을 사용할 수 있는 Map

5-3. Comparable과 Comparator
- TreeSet과 TreeMap에 저장되는 키 객체는 저장과 동시에 오름차순으로 정렬된다.
-- 객체가 Comparable을 구현하고 있어야 가능하다.
- comparableTo(T o) 메소드를 재정의해서 정렬 방식을 변경할 수 있다.

- comparable 비구현 객체 생성
-- 비교자 생성자를 매개 변수로 사용해서 TreeSet이나 TreeMap을 생성하면 된다.
--- 비교자: Comparable 인터페이스를 구현한 객체.

6. LIFO와 FIFO 컬렉션
- LIFO(후입 선출): 나중에 넣은 객체가 먼저 빠져나감
-- Stack
- FIFO(선입 선출): 먼저 넣은 객체가 먼저 빠져나감
-- Queue

6-1. Stack
리턴 타입 | 메소드        | 설명
E        | push(E item) | 주어진 객체를 스택에 넣는다
E        | pop()        | 스택 맨 위 객체를 빼낸다

6-2. Queue
리턴 타입 | 메소드        | 설명
boolean  | offer(E e)   | 주어진 객체를 큐에 넣는다
E        | poll()        | 큐에서 객체를 빼낸다

7. 동기화된 컬렉션
- Collection은 비동기화된 메소드를 동기화된 메소드로 변환하는 메소드를 지닌다.
리턴 타입 | 메소드        | 설명
List<T>   | SynchronizedList(List<T> list) | List를 동기환된 List로 리턴
Map<K, V> | SynchronizedMap(Map<K, V> m)   | Map을 동기환된 Map으로 리턴
Set<T>    | SynchronizedSet(Set<T> s)      | Set을 동기환된 Set으로 리턴

8. 수정할 수 없는 컬렉션
- List, Set, Map 인터페이스의 정적 메소드 of()로 생성할 수 있다.
- List, Set, Map 인터페이스의 정적 메소드 copyOf()를 이용해 기존 컬렉션을 복사하여 수정할 수 없는 컬렉션을 생성할 수 있다.
- Array.asList()로 불변 List를 생성할 수 있다. 